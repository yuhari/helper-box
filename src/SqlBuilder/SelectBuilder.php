<?php
/**
 *
 * The content is generated by using TextMate, and edited by yuhari.
 * 
 *
 * mysql query builder
 *
 *
 * @author 	   yuhari
 * @maintainer yuhari
 * @version    1.0.0
 * @modified   2018/07/21 16:11:43
 *
 */
namespace box\SqlBuilder ;

class SelectBuilder extends AbstractBuilder {
	
	//select column fields.
	protected $columns = array() ;
	
	// order by
	protected $order = array() ;
	
	// group by
	protected $group = array() ;
	
	// having
	protected $having = array() ;
	
	// limit,offset
	protected $limit = array() ;
	
	// for update
	protected $for_update = false ;
	
	/**
	 * generate sql string
	 *
	 * @return string
	 */
	public function getSqlString() {
		
		$clause = 'SELECT '
			. $this->buildSelect()
			. ' From ' . $this->buildTables()
			. $this->buildWhere()
			. $this->buildGroup() 
			. $this->buildHaving() 
			. $this->buildOrder() 
			. $this->buildLimit() 
			. $this->buildForUpdate() ;
		
		return $clause ;
	}
	
	/**
	 * reset query values.
	 *
	 * @param  default
	 * @return $this
	 */
	public function reset() {
		
		$this->select = array() ;
		$this->from = array() ;
		$this->from_key = -1 ;
		$this->join = array() ;
		$this->where = array() ;
		$this->group = array() ;
		$this->having = array() ;
		$this->order = array() ;
		$this->limit = array() ;
		$this->bind_values = array() ;
		$this->alias = null ;
		
		$this->for_update = false ;
		
		return $this ;
	}
	
	/**
	 * add columns into the query .
	 *
	 * @param  array $columns.
	 * @return $this
	 */
	public function select(array $columns=array()) {
		if (empty($columns)) {
			$this->addColumn(0, '*') ;
		}else{
			foreach($columns as $k => $v) {
				$this->addColumn($k, $v) ;
			}
		}
		
		return $this ;
	}
	
	/**
	 * add column
	 *
	 * @param  mixed $k , column or default key
	 * @param  mixed $v , alias or column
	 * @return void
	 */
	protected function addColumn($k, $v) {
		
		if (is_string($k)) {
			// column => alias
			$this->columns[$v] = $k ;
		} else {
			// promise the column that contains mysql funcion doesn't have unnecessary blank .  
			$p = explode(' ', $v) ;
			$c = count($p) ;
			if ($c == 2) {
				// column alias
				$this->columns[$p[1]] = $p[0] ;
			} elseif ($c == 3 && strtoupper($p[1]) == 'AS') {
				// column as alias
				$this->columns[$p[2]] = $p[0] ;
			} else {
				$this->columns[] = $v ;
			}
		}
	}
	
	/**
	 * add an order clause .
	 * support array('id desc','uid'=>'desc')
	 *
	 * @param  array|string $spec
	 * @return $this
	 */
	public function order($spec) {
		if (is_array($spec)) {
			foreach($spec as $k => $v) {
				if (is_string($k) && in_array(strtoupper($v) , array('RAND', 'DESC', 'ASC'))) {
					$this->order[] = "$k " . strtoupper($v) ;
				} else {
					$this->order[] = $v ;
				}
			}
		}else {
			$this->order[] = $spec ;
		}
		
		return $this ;
	}
	
	/**
	 * add a group-by clause .
	 *
	 * @param  array|string $spec
	 * @return $this
	 */
	public function group($spec) {
		if (is_array($spec)) {
			foreach($spec as $k => $v) {
				$this->group[] = $v ;
			}
		}else {
			$this->group[] = $spec ;
		}
		
		return $this ;
	}
	
	/**
	 * set a offset-limit clause .
	 *
	 * @param  limit || offset, limit
	 * @return $this
	 */
	public function limit() {
		$args = func_get_args() ;
		if (count($args) == 1) {
			$this->limit = array(0, $args[0]) ;
		}elseif (count($args) > 1) {
			$this->limit = array($args[0], $args[1]) ;
		}
		
		return $this ;
	}
	
	/**
	 * combine having clause .
	 *
	 * @param  
	 * @return $this 
	 */
	public function having($andor, $cond, array $bind_values = array()) {
		
		if (!in_array(strtoupper($andor), array('AND', 'OR'))) {
			$bind_values = $cond ;
			$cond = $andor ;
			$andor = 'AND' ;
		}else{
			$andor = strtoupper($andor) ;
		}
		
		$cond = $this->rebuildCondAndValues($cond, $bind_values) ;
		if (empty($this->having)) {
			$this->having[] = $cond ;
		}else{
			$this->having[] = "$andor $cond" ;
		}
		
		return $this ;
	}
	
	/**
	 * for update
	 *
	 * @param  boolean $bool
	 * @return $this
	 */
	public function forUpdate($bool = true) {
		$this->for_update = true ;
		return $this ;
	}
	
	/**
	 * build select field string .
	 *
	 * @param  null
	 * @return string
	 */
	protected function buildSelect() {
		if (empty($this->columns)) {
			return '*' ;
		}
		
		$t = array() ;
		foreach($this->columns as $k => $v) {
			if (is_string($k)) {
				$t[] = "$k AS $v" ;
			}else {
				$t[] = $v ;
			}
		}

		$clause = implode(',', $t) ;
		return $clause ;
	}
	
	/**
	 * function description
	 *
	 * @param  default
	 * @return void
	 */
	protected function buildGroup() {
		$clause = '' ;
		
		if (!empty($this->group)) {
			$clause = ' GROUP BY ' . implode(',', $this->group) ; 
		}
		
		return $clause ;
	}
	
	/**
	 * function description
	 *
	 * @param  default
	 * @return void
	 */
	protected function buildHaving() {
		$clause = '' ;
		
		if (!empty($this->having)) {
			$clause = ' HAVING ' . implode(' ' , $this->having) ;
		}
		
		return $clause ;
	}
	
	/**
	 * function description
	 *
	 * @param  default
	 * @return void
	 */
	protected function buildOrder() {
		$clause = '' ;
		
		if (!empty($this->order)) {
			$clause = ' ORDER BY ' . implode(',', $this->order) ;
		}
		
		return $clause ;
	}
	
	/**
	 * for update string
	 *
	 * @param  default
	 * @return string
	 */
	protected function buildForUpdate() {
		return $this->for_update ? ' FOR UPDATE' : '' ;
	}
	
	/**
	 * function description
	 *
	 * @param  default
	 * @return void
	 */
	public function buildLimit() {
		$clause = '' ;
		
		if (!empty($this->limit)) {
			$clause = ' LIMIT ' . $this->limit[0] . ',' . $this->limit[1] ;
		}
		
		return $clause ;
	}

}
